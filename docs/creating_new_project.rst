.. _create_new_project:

Creating a new MarineMap project
=================================

.. note::

   Though lingcod includes several example projects, you are encouraged to 
   create your MarineMap instance as a seperate python package outside of the 
   lingcod source tree. This will allow for clear seperation between the underlying
   libraries (lingcod) and your implementation of MarineMap (the "project")


Install Dependencies
---------------------

You will need to install lingcod's dependencies and lingcod itself. For detailed instructions, please follow :ref:`Getting Started <getting_started>`.

Create new django project
--------------------------

In this example, we'll set up a new MarineMap instance for the state of Oregon. We use django-admin.py to create a standard django project:: 

    cd ~/oregon_stuff
    django-admin.py startproject oregon

You should see the following directory structure::

    oregon
    |-- __init__.py
    |-- manage.py
    |-- settings.py
    `-- urls.py

We now need to configure the settings and urls for our oregon project.

Settings
--------

First, while we appreciate django-admin's attempt at an initial settings.py file, it doesn't really work for us in this case. Because lincod contains sensible default settings, we only need to worry about MarineMap specific settings and django settings unique to this project. You can delete all the lines in settings.py *except* for the SECRET_KEY and add the following::

    # Django settings for oregon project.
    from lingcod.common.default_settings import *

    BASE_DIR = os.path.dirname(os.path.abspath(__file__))

    DATABASES = {
        'default': {
            'ENGINE': 'django.contrib.gis.db.backends.postgis',
            'NAME': 'oregon',
            'USER': 'postgres',
        }
    }

    TIME_ZONE = 'America/Vancouver'
    LANGUAGE_CODE = 'en-us'
    SITE_ID = 1
    USE_I18N = True

    SECRET_KEY = 'keep_the_one_autogenerated_by_django-admin'

    ROOT_URLCONF = 'oregon.urls'

    TEMPLATE_DIRS = ( os.path.realpath(os.path.join(os.path.dirname(__file__), 'templates').replace('\\','/')), )

    INSTALLED_APPS += ( 'omm', )

Notice the final line; Here we install an app called 'omm' that will hold the project specific models, views and templates. Let's go ahead and create that app and configure it for edit and create custom features.

Creating Features and FeatureCollections
----------------------------------------

Lingcod is designed without any hardcoded feature types (though we do provide plenty of examples!). `Features` are the geographic entities that users can create, edit, share and analyze. Each custom type of feature can be set up with it's own attributes, it's own behavior and it's own relationships with other features. `FeatureCollections` are a special type of Feature that allows you to organize Features into logical sets or even nested hierarchies; they are analagous to directories in your operating system except that you can define their behavior and their relationships with other features. 

Let's start with a simple example. Let's say we want to develop a collaborative system for creating, sharing and analyzing Marine Protected Areas (MPAs). We also want to be able to put these MPAs into Folders to keep things organized. 


First we *must* create the app to hold our custom features::

    cd oregon
    python manage.py startapp omm
    
Here we should see the following directory structure created for us::

    omm
    |-- __init__.py
    |-- models.py
    |-- tests.py
    `-- views.py

We can ignore the tests and views for now; for now we'll focus on creating the Mpa and Folder models. Open omm/models.py and add::

    from lingcod.features.models import PolygonFeature, FeatureCollection
    from lingcod.features.forms import SpatialFeatureForm
    from lingcod.features import *

    @register
    class Mpa(PolygonFeature):
        class Options:
            form = 'oregon.omm.models.MpaForm'

    class MpaForm(SpatialFeatureForm):
        class Meta(SpatialFeatureForm.Meta):
            model = Mpa

The above is a barebones MPA feature inherited from the `PolygonFeature` base class. This means that all the basic attributes are included by default. A form for creating and editing Mpas is also provided; again inheriting from a `SpatialFeatureForm` base class so the default behavior takes very few lines of code. The only additional information required is the Options class with a form property specifying the full python path to the associated Form (mandatory). Finally the @register decorator at the top of the class is required to register `Mpa` Features with lingcod. 

While this is the bare minimum to create a feature, it's not a very interesting example. From here we might want to expand on the configuration a bit, adding manipulators, attributes, verbose name, and custom links to the Options::

    @register
    class Mpa(PolygonFeature):
        designation = models.CharField()
        class Options:
            verbose_name = 'Marine Protected Area'
            form = 'oregon.omm.models.MpaForm'
            manipulators = [ 'lingcod.manipulators.manipulators.ClipToStudyRegion' ]
            optional_manipulators = [ 'lingcod.manipulators.manipulators.ClipToGraticuleManipulator' ]
            links = (
                related('Habitat Spreadsheet',
                    'oregon.omm.views.habitat_spreadsheet',
                    select='single',
                    type='application/xls'
                ),
            )

.. note::
    
    The above `Mpa` feature has a custom link for a Habitat Spreadsheet; the oregon.omm.views.habitat_spreadsheet view would need to be written for this to function properly. For more info see documentation on Creating Link Views TODO.

Similarly, we could group Mpas into collections called Arrays. We can inherit from the base `FeatureCollection` and specify the mandatory `valid_children` Option to configure which feature types can be placed in a folder.:: 

    @register
    class Array(FeatureCollection):
        class Options:
            form = 'lingcod.features.tests.ArrayForm'
            valid_children = (
                'oregon.omm.models.Mpa', 
                'oregon.omm.models.Array', 
            )

    class ArrayForm(FeatureForm):
        class Meta:
            model = Array

With few lines of code, we've defined the features and aspects of our application's behavior. One of our goals is to make the customization and configuration of lingcod as easy as possible - and its almost entirely driven by the model configurations you see above. There are few other things you need to do in order to get a fullly functional application. 

Urls
----

In order for django to successfully route requests, we need to define URL patterns for the common lingcod operations. Lingcod provides a set of default urls so for the common use case, just modify your urls.py to show the following::

    from django.conf.urls.defaults import *
    from django.contrib import admin
    admin.autodiscover()

    urlpatterns = patterns('',
        # Include all lingcod app urls. Any urls above will overwrite the common urls below
        (r'', include('lingcod.common.urls')),
    )



Databases
----------

Next we'll create a new postgis-enabled database for this project and use django's syncdb command to create the necessary tables. Assuming you installed postgis functions, etc into your postgres template1, this is as simple as::

    createdb oregon -U postgres

Study Region
-------------
Every project should define a :ref:`study region<study_region>` if the ClipToStudyRegion manipulator will be used.
The study region is a (multi)polygon shape which defines where
shapes can be created. Because new shapes are clipped to this study region boundary, it is highly
recomended to give this step great consideration up front; changing the study region boundary at a
later date is MUCH more complicated. 

Let's assume that we have created a shapefile containing a single polyon feature representing the waters within 5 kilometers
of the oregon coast. This shapefile is in UTM Zone 10N, WGS84 datum which corresponds to the 
SRID 32610 (see http://www.spatialreference.org/ref/epsg/32610/). This is also the projection we want to use for storing our 
shapes so we'll add this to our settings.py::

    GEOMETRY_DB_SRID = 32610

First we have to create some necessary table in the database::

    python manage.py syncdb
    python manage.py migrate

Next, we'll use some custom lingcod management commands to load up our carefully and meticulously created study region::

    python manage.py create_study_region --name oregon_coast data/oregon_study_region.shp
    python manage.py change_study_region 1

Migrating our `omm` app
-----------------------
We need to put our omm app under migration which ensures that future changes to the models' schema get reflected in the database::

    python manage.py schemamigration --initial omm
    python manage.py migrate omm --fake

Static Media
------------
All static media is split between the project and the lingcod library. The project media goes in a 'media' directory at the same level as your project directory. (ie ~/oregon_stuff/oregon/ is your django project, ~/oregon_stuff/media is your oregon media dir). First you must define the MEDIA_ROOT in our settings.py file::

    MEDIA_ROOT = '/var/www/oregon_media'

The install_media command will then take all files from lingcod media and oregon media directories and combine them into this directory. It is safe to assume that when you deploy marinemap you'll want this directory to be fully web accessible::

    python manage.py install_media 

This step also compresses all js and css using the django-compress app to ensure that your js and css are single compact files to maximize performance. 

Deployment
----------

For now, we'll just test our new project using django's built-in development server. First we need to set up the sites framework so that our domain is accurate
for any absolute urls created by our MarineMap project. Then run the dev server to test it::

    python manage.py enable_sharing
    python manage.py site_setup_for_dev
    python manage.py runserver

Our Oregon MarineMap project should now be accessible at http://localhost:8000/


Next steps
----------
MarineMap has fixtures containing test data that is installed on database 
setup like an example :ref:`Study Region <study_region>` and :ref:`layers`. This makes
it easy to verify the installation and learn how the tool works. For use in an 
actual planning session these default datasets will need to be replaced.

See the documentation in the following sections to customize MarineMap as 
needed:

.. toctree::
   :maxdepth: 1
   
   feature_classes
   study_region
   deployment
   layers
   managing_users
   static_map_configuration
   sharing_configuration
   kml_configuration
   template_customization
   
The setup this guide has walked through only specifies how to run the django
development server. To setup a public facing website using Apache, consult the
:ref:`deployment` notes.
